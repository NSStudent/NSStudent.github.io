


[{"content":"","date":"December 28, 2025","externalUrl":null,"permalink":"/tags/ajedrez/","section":"Tags","summary":"","title":"Ajedrez","type":"tags"},{"content":"","date":"27 December 2025","externalUrl":null,"permalink":"/en/tags/bitboard/","section":"Tags","summary":"","title":"Bitboard","type":"tags"},{"content":"For a while now I\u0026rsquo;ve been working on connecting two fields I\u0026rsquo;m really interested in: Swift programming and chess.\nAs is well known, these two worlds have been linked since the early days of computing: from Claude Shannon\u0026rsquo;s early work on chess as a computational problem, through the era of iconic machines like Deep Blue facing Kasparov, to the present with engines like Stockfish.\nIn this article we will dive into one of the fundamental concepts of any modern chess engine or library: bitboards.\nThe explanation is based on three pillars:\nThe classic definition described in ChessProgramming Wiki The first Swift implementation I found on the topic, which I used as a reference: Sage The implementation this article is based on (link) The goal is not only to understand what a bitboard is, but why this approach is so powerful when we work with chess logic.\nWhat is a Bitboard? # A bitboard is, conceptually, a 64-bit integer (UInt64) where each bit represents a square on the chessboard.\nSince the board has exactly 64 squares (8×8), the fit is perfect:\n1 bit = 1 square Bit 1 → there is something on that square Bit 0 → the square is empty The square order relative to the bit is represented in the following image: For example, if we wanted to represent the position of all the white pawns in this image: We would mark occupied squares with a 1 and order them as shown before, resulting in the following number Why not use an 8×8 matrix? # The most intuitive way to represent a board is something like:\n[[Piece?]] // 8x8 This works, but it has several problems when we want performance:\nIndirect memory access Many conditions (if, guard) Hard to calculate attacks in bulk Poor CPU utilization Bitboards, on the other hand, allow:\nOperations in a single instruction Heavy use of bitwise operations (\u0026amp;, |, ^, \u0026lt;\u0026lt;, \u0026gt;\u0026gt;) Parallel calculation of moves and attacks In chess, where every move counts, that makes a huge difference.\nA board as a set of bitboards # A key idea is that there is not just one bitboard, but several.\nFor a position on a board we need to represent different piece types:\n8 white pawns (we already saw how to represent them with a single bitboard). 2 white rooks. 2 white knights. 2 white bishops. The white king. The white queen. The equivalent for the black pieces. So with 12 bitboards we have what we need to represent a full board position.\nOur implementation: Bitboard as a domain type # In the library we do not use UInt64 directly everywhere. Instead, we encapsulate the concept in a dedicated type:\npublic struct Bitboard { private(set) var rawValue: UInt64 } This has several advantages:\nStrong typing (we do not mix “normal” integers with bitboards) Expressive API Safety and readability Ability to add chess-specific behavior A Bitboard is not a number, it is a domain concept.\nBitwise operations as the language of chess # With the 12 bitboards defined we can answer questions like:\nWhich squares are occupied? Which squares are free? Which squares does this piece attack? Everything is built on binary operations.\nOR (|) – union # Thinking of bitboards as the set of the 12 bitboards of a position, we get the set of occupied squares like this:\npublic var occupiedSpaces: Bitboard { return bitboards.reduce(0, |) } NOT (~) – complement # Once we have the occupied squares, it is easy to detect the empty ones as the complement:\npublic var emptySpaces: Bitboard { return ~occupiedSpaces } We can implement all the binary logical operators we want, here is an example:\nextension Bitboard { public static func \u0026lt;\u0026lt; (lhs: Bitboard, rhs: Bitboard) -\u0026gt; Bitboard { let shifted = lhs.rawValue \u0026lt;\u0026lt; rhs.rawValue return Bitboard(rawValue: shifted) } public static func \u0026gt;\u0026gt; (lhs: Bitboard, rhs: Bitboard) -\u0026gt; Bitboard { let shifted = lhs.rawValue \u0026gt;\u0026gt; rhs.rawValue return Bitboard(rawValue: shifted) } public static func \u0026lt;\u0026lt;= (lhs: inout Bitboard, rhs: Bitboard) { lhs = lhs \u0026lt;\u0026lt; rhs } public static func \u0026gt;\u0026gt;= (lhs: inout Bitboard, rhs: Bitboard) { lhs = lhs \u0026gt;\u0026gt; rhs } public static func \u0026amp; (lhs: Bitboard, rhs: Bitboard) -\u0026gt; Bitboard { Bitboard(rawValue: lhs.rawValue \u0026amp; rhs.rawValue) } public static func | (lhs: Bitboard, rhs: Bitboard) -\u0026gt; Bitboard { Bitboard(rawValue: lhs.rawValue | rhs.rawValue) } public static func ^ (lhs: Bitboard, rhs: Bitboard) -\u0026gt; Bitboard { Bitboard(rawValue: lhs.rawValue ^ rhs.rawValue) } public static func \u0026gt; (lhs: Bitboard, rhs: Bitboard) -\u0026gt; Bool { lhs.rawValue \u0026gt; rhs.rawValue } public static func \u0026lt; (lhs: Bitboard, rhs: Bitboard) -\u0026gt; Bool { lhs.rawValue \u0026lt; rhs.rawValue } public static prefix func ~ (board: Bitboard) -\u0026gt; Bitboard { Bitboard(rawValue: ~board.rawValue) } } Iterating squares: popcount and bit scan # Another key point is iterating only over active squares, not all 64.\nInstead of:\nfor square in 0..\u0026lt;64 We use techniques like:\npopcount → number of active bits extracting the least significant bit clearing the bit once processed In our implementation, the Bitboard iterator does exactly that: it keeps popping the LS1B (least significant set bit) with popLSB() until the board is empty. Internally we use the classic trick described in BitScan:\nextension Bitboard { /// A lookup table of least significant bit indices. private static let lsbTable: [Int] = [00, 01, 48, 02, 57, 49, 28, 03, 61, 58, 50, 42, 38, 29, 17, 04, 62, 55, 59, 36, 53, 51, 43, 22, 45, 39, 33, 30, 24, 18, 12, 05, 63, 47, 56, 27, 60, 41, 37, 16, 54, 35, 52, 21, 44, 32, 23, 11, 46, 26, 40, 15, 34, 20, 31, 10, 25, 14, 19, 09, 13, 08, 07, 06] /// A lookup table of most significant bit indices. private static let msbTable: [Int] = [00, 47, 01, 56, 48, 27, 02, 60, 57, 49, 41, 37, 28, 16, 03, 61, 54, 58, 35, 52, 50, 42, 21, 44, 38, 32, 29, 23, 17, 11, 04, 62, 46, 55, 26, 59, 40, 36, 15, 53, 34, 51, 20, 43, 31, 22, 10, 45, 25, 39, 14, 33, 19, 30, 09, 24, 13, 18, 08, 12, 07, 06, 05, 63] /// A lookup table of bitboards for all squares. private static let bitboardTable: [Bitboard] = (0 ..\u0026lt; 64).map { Bitboard(rawValue: 1 \u0026lt;\u0026lt; $0) } /// The De Bruijn multiplier. private static let debruijn64: UInt64 = 0x03f79d71b4cb0a89 /// Returns the index of the lsb value. private func index(lsb value: Bitboard) -\u0026gt; Int? { guard value != 0 else { return nil } return Bitboard.lsbTable[Int((value.rawValue \u0026amp;* Bitboard.debruijn64) \u0026gt;\u0026gt; 58)] } /// The least significant bit. public var lsb: Bitboard { return Bitboard(rawValue: rawValue \u0026amp; (0 \u0026amp;- rawValue)) } /// The index for the least significant bit of `self`. public var lsbIndex: Int? { return index(lsb: lsb) } /// The square for the least significant bit of `self`. public var lsbSquare: Square? { return lsbIndex.flatMap({ Square(rawValue: $0) }) } private var msbShifted: UInt64 { var x = rawValue x |= x \u0026gt;\u0026gt; 1 x |= x \u0026gt;\u0026gt; 2 x |= x \u0026gt;\u0026gt; 4 x |= x \u0026gt;\u0026gt; 8 x |= x \u0026gt;\u0026gt; 16 x |= x \u0026gt;\u0026gt; 32 return x } /// The most significant bit. public var msb: Bitboard { return Bitboard(rawValue: (msbShifted \u0026gt;\u0026gt; 1) + 1) } /// The index for the most significant bit of `self`. public var msbIndex: Int? { guard rawValue != 0 else { return nil } return Bitboard.msbTable[Int((msbShifted \u0026amp;* Bitboard.debruijn64) \u0026gt;\u0026gt; 58)] } /// The square for the most significant bit of `self`. public var msbSquare: Square? { return msbIndex.flatMap({ Square(rawValue: $0) }) } /// Removes the least significant bit and returns it. public mutating func popLSB() -\u0026gt; Bitboard { let lsb = self.lsb rawValue -= lsb.rawValue return lsb } /// Removes the least significant bit and returns its index, if any. public mutating func popLSBIndex() -\u0026gt; Int? { return index(lsb: popLSB()) } /// Removes the least significant bit and returns its square, if any. public mutating func popLSBSquare() -\u0026gt; Square? { return popLSBIndex().flatMap({ Square(rawValue: $0) }) } } lsb = x \u0026amp; -x with this operation we isolate the least significant active bit (the 1 that is lowest in the binary number) Thanks to the De Bruijn tables and the private func index(lsb value: Bitboard) -\u0026gt; Int? function we can get the index to know the square We call popLSB to remove that bit and continue iterating. public struct Bitboard: Equatable, Hashable { private(set) var rawValue: UInt64 = 0 public init(rawValue: UInt64) { self.rawValue = rawValue } public init() {} /// An iterator over the squares set in a `Bitboard`. /// /// Iterates by popping least significant bits until the bitboard is empty. public struct Iterator: IteratorProtocol { fileprivate var bitboard: Bitboard /// Returns the next square in the bitboard by removing the least significant bit. public mutating func next() -\u0026gt; Square? { return bitboard.popLSBSquare() } } } This greatly reduces the computational cost, especially for move generation, because we only walk the squares with pieces instead of all 64.\nConclusion # Bitboards are not just an optimization:\nthey are a different way to think about chess in code.\nBy representing the board as binary data:\nChess becomes algebra Moves become operations The position becomes a compact, efficient state In upcoming articles we will see how to generate attack bitboards for each piece, build complete positions, and legal move generation from this base.\n","date":"27 December 2025","externalUrl":null,"permalink":"/en/posts/1766836145577-swift-chess-01/","section":"Posts","summary":"","title":"Bitboards: Representing the Chessboard Efficiently","type":"posts"},{"content":"","date":"27 December 2025","externalUrl":null,"permalink":"/en/tags/chess/","section":"Tags","summary":"","title":"Chess","type":"tags"},{"content":"","date":"27 December 2025","externalUrl":null,"permalink":"/en/","section":"NSStudent blog","summary":"","title":"NSStudent blog","type":"page"},{"content":"","date":"27 December 2025","externalUrl":null,"permalink":"/en/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"27 December 2025","externalUrl":null,"permalink":"/en/tags/swift/","section":"Tags","summary":"","title":"Swift","type":"tags"},{"content":"","date":"27 December 2025","externalUrl":null,"permalink":"/en/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":" Intro # Publish is an awesome static site generator created by John Sundell. This website is built with this tool.\nOne of the steps is to upload to the server all the file generated, the first approach I used was to upload all the files in the output folder, via FTP manually but, then I had an idea.\nDeploy # For deployment, I use the following code:\n.publish( withTheme: .nsstudent, deployedUsing: DeploymentMethod.gitHub(\u0026#34;NSStudent/NSStudent\u0026#34;), ... } This is the implementation of the github method:\n/// Deploy a website to a given GitHub repository. /// - parameter repository: The full name of the repository (including its username). /// - parameter useSSH: Whether an SSH connection should be used (preferred). static func gitHub(_ repository: String, useSSH: Bool = true) -\u0026gt; Self { let prefix = useSSH ? \u0026#34;git@github.com:\u0026#34; : \u0026#34;https://github.com/\u0026#34; return git(\u0026#34;\\(prefix)\\(repository).git\u0026#34;) } This method searches the repository with the name NSStudent/NSStudent. By default, the implementation tries to clone the repository via SSH with this code inside the git method.\nstatic func git(_ remote: String) -\u0026gt; Self { DeploymentMethod(name: \u0026#34;Git (\\(remote))\u0026#34;) { context in let folder = try context.createDeploymentFolder(withPrefix: \u0026#34;Git\u0026#34;) { folder in if !folder.containsSubfolder(named: \u0026#34;.git\u0026#34;) { try shellOut(to: .gitInit(), at: folder.path) try shellOut( to: \u0026#34;git remote add origin \\(remote)\u0026#34;, at: folder.path ) } try shellOut( to: \u0026#34;git remote set-url origin \\(remote)\u0026#34;, at: folder.path ) _ = try? shellOut( to: .gitPull(remote: \u0026#34;origin\u0026#34;, branch: \u0026#34;master\u0026#34;), at: folder.path ) try folder.empty() } let dateFormatter = DateFormatter() dateFormatter.dateFormat = \u0026#34;yyyy-MM-dd HH:mm\u0026#34; let dateString = dateFormatter.string(from: Date()) do { try shellOut( to: \u0026#34;\u0026#34;\u0026#34; git add . \u0026amp;\u0026amp; git commit -a -m \\\u0026#34;Publish deploy \\(dateString)\\\u0026#34; --allow-empty \u0026#34;\u0026#34;\u0026#34;, at: folder.path ) try shellOut( to: .gitPush(remote: \u0026#34;origin\u0026#34;, branch: \u0026#34;master\u0026#34;), at: folder.path ) } catch let error as ShellOutError { throw PublishingError(infoMessage: error.message) } catch { throw error } } } The magic happens when the context calls context.createDeploymentFolder function. This method creates a new folder with the name GitDeploy inside to a hidden folder .publish.\nRight now, all the codes are in your repository.\nTo create the action to upload the website in the server via FTP, you need to add the following main.yml file:\nname: Deploy website on: [push] jobs: FTP-Deploy-Action: name: FTP-Deploy-Action runs-on: ubuntu-latest steps: - uses: actions/checkout@master - name: FTP-Deploy-Action uses: SamKirkland/FTP-Deploy-Action@2.0.0 env: FTP_SERVER: ${{ secrets.FTP_NAME }} FTP_USERNAME: ${{ secrets.FTP_USER }} FTP_PASSWORD: ${{ secrets.FTP_PASSWORD }} ARGS: --delete --exclude-glob=.git*/** --exclude-glob=.git** --delete-excluded This file use the FTP-Deploy-Action. It has three secrets variables secrets.FTP_NAME, secrets.FTP_USER, secrets.FTP_PASSWORD to not expose the real values. The ARGS parameter tries to remove all unused files and it prevents the upload off all the files inside the .git or .github folders.\nYou need to pull this change in the current GitDeploy repository. Right now, every time you use Publish deploy in the terminal and push a new version in this repository, the action uploads all the files to the FTP.\nI will try to write with new things about Publish and how I use them in this blog.\n","date":"10 November 2024","externalUrl":null,"permalink":"/en/posts/1731268430539-deploy-with-github-actions/","section":"Posts","summary":"","title":"Deploy Publish blog with Github Actions","type":"posts"},{"content":"","date":"10 November 2024","externalUrl":null,"permalink":"/en/tags/publish/","section":"Tags","summary":"","title":"Publish","type":"tags"},{"content":"","date":"November 6, 2024","externalUrl":null,"permalink":"/tags/blogging/","section":"Tags","summary":"","title":"Blogging","type":"tags"},{"content":" Introducción # Hugo es un generador de sitios estáticos rápido y flexible que permite crear y personalizar blogs de manera sencilla. Publicar tu blog en GitHub Pages es una excelente manera de alojarlo de forma gratuita y con alta disponibilidad. En esta guía, aprenderás a crear un blog con Hugo y publicarlo en GitHub Pages paso a paso.\nPrerrequisitos # Antes de comenzar, asegúrate de tener lo siguiente:\nGit instalado en tu máquina. Hugo instalado. Una cuenta en GitHub. Crear tu Blog con Hugo # Inicializar un Nuevo Proyecto de Hugo\nCrea un directorio para tu blog e inicializa el proyecto:\nmkdir MiBlog cd MiBlog hugo new site . Elegir un Tema\nBusca un tema que te guste en Hugo Themes y clónalo en tu proyecto:\ngit init git submodule add https://github.com/\u0026lt;autor\u0026gt;/\u0026lt;tema\u0026gt;.git themes/\u0026lt;tema\u0026gt; echo \u0026#39;theme = \u0026#34;\u0026lt;tema\u0026gt;\u0026#34;\u0026#39; \u0026gt;\u0026gt; config.toml Crear tu Primer Artículo\nGenera un archivo de contenido:\nhugo new posts/mi-primer-articulo.md Edita el archivo creado en content/posts/mi-primer-articulo.md y agrega contenido relevante.\nPrevisualizar el Blog Localmente\nInicia el servidor de desarrollo para ver tu blog en el navegador:\nhugo server Abre http://localhost:1313 en tu navegador para ver tu blog.\nPublicar en GitHub Pages # Crear un Repositorio en GitHub\nVe a GitHub y crea un nuevo repositorio. Anota la URL del repositorio.\nConfigurar el Repositorio Local\nConecta tu proyecto a GitHub:\ngit remote add origin https://github.com/\u0026lt;tu-usuario\u0026gt;/\u0026lt;repositorio\u0026gt;.git Configurar la Rama para Publicación\nHugo genera los archivos del sitio estático en el directorio public. Configuraremos esta carpeta como la rama gh-pages:\nhugo cd public git init git remote add origin https://github.com/\u0026lt;tu-usuario\u0026gt;/\u0026lt;repositorio\u0026gt;.git git checkout -b gh-pages git add . git commit -m \u0026#34;Publicar sitio inicial\u0026#34; git push origin gh-pages --force Configurar GitHub Pages\nVe a la configuración del repositorio en GitHub, selecciona Pages, y elige la rama gh-pages como fuente.\nAutomatizar Publicaciones (Opcional)\nPuedes configurar GitHub Actions para automatizar la publicación cada vez que hagas un cambio:\nCrea un archivo .github/workflows/deploy.yml: name: Deploy Hugo Site on: push: branches: - main jobs: deploy: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 with: submodules: true - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;latest\u0026#39; - name: Build run: hugo - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: github_token: ${{ secrets.GITHUB_TOKEN }} publish_dir: ./public Realiza un commit y haz un push del archivo. Extra: Publicar en el github-page del usuario con un Submódulo # Si quieres usar el repositorio especial \u0026lt;User\u0026gt;.github.io para alojar tu blog, puedes configurar la carpeta public como un submódulo. Este método permite que tu código fuente y los archivos generados del sitio estén separados, manteniendo el repositorio principal limpio.\nPasos: # Crear el Repositorio Especial\nVe a GitHub y crea un repositorio con el nombre exacto \u0026lt;User\u0026gt;.github.io.\nConfigurar el Submódulo para public\nDesde la raíz de tu proyecto Hugo, añade el repositorio como submódulo vinculado a la carpeta public:\ngit submodule add -b main https://github.com/\u0026lt;User\u0026gt;/\u0026lt;User\u0026gt;.github.io.git public Generar el Sitio Estático\nConstruye el sitio estático de Hugo, que generará los archivos en la carpeta public:\nhugo Publicar los Archivos en \u0026lt;User\u0026gt;.github.io\nNavega a la carpeta public, agrega y realiza un commit de los archivos generados, y luego súbelos al repositorio remoto:\ncd public git add . git commit -m \u0026#34;Publicar sitio inicial\u0026#34; git push origin main cd .. Guardar el Código Fuente del Blog\nVuelve al repositorio principal (el directorio raíz de tu proyecto Hugo) y realiza un commit de los cambios relacionados con el submódulo:\ngit add . git commit -m \u0026#34;Configurar submódulo para publicar en GitHub Pages\u0026#34; git push origin main Configurar GitHub Pages\nGitHub detectará automáticamente el contenido publicado en el repositorio \u0026lt;User\u0026gt;.github.io y lo servirá desde https://\u0026lt;User\u0026gt;.github.io.\nNotas: # Cada vez que realices cambios en tu blog y generes los archivos estáticos, deberás navegar a la carpeta public, hacer un commit y un push para actualizar tu sitio. Si deseas automatizar este proceso, puedes configurar un script o usar GitHub Actions. Esta opción es ideal si prefieres que tu blog esté alojado en el dominio principal de GitHub Pages (\u0026lt;User\u0026gt;.github.io) en lugar de un subdirectorio.\nConclusión # ¡Eso es todo! Ahora tienes un blog funcional en Hugo alojado gratuitamente en GitHub Pages. Puedes personalizarlo, agregar más artículos y compartir tu contenido con el mundo. Si necesitas más ayuda, consulta la documentación oficial de Hugo y GitHub Pages.\n","date":"November 6, 2024","externalUrl":null,"permalink":"/posts/1731339196748-crear-blog-en-hugo/","section":"Posts","summary":"","title":"Crear un Blog con Hugo y Publicarlo en GitHub Pages","type":"posts"},{"content":"","date":"November 6, 2024","externalUrl":null,"permalink":"/tags/espa%C3%B1ol/","section":"Tags","summary":"","title":"Español","type":"tags"},{"content":"","date":"November 6, 2024","externalUrl":null,"permalink":"/tags/github-pages/","section":"Tags","summary":"","title":"Github-Pages","type":"tags"},{"content":"","date":"November 6, 2024","externalUrl":null,"permalink":"/tags/hugo/","section":"Tags","summary":"","title":"Hugo","type":"tags"},{"content":"","date":"11 November 2020","externalUrl":null,"permalink":"/en/tags/basics/","section":"Tags","summary":"","title":"Basics","type":"tags"},{"content":"Structs create a default initializer when you implement one.\nSometimes you want to create another initializer to facilitate the code.\nThe problems appear when you try to introduce our initializer. the default constructor disappears. To avoid this problem, the best way is to include our initializer inside an extension.\nThis way, we\u0026rsquo;ll keep the two builders\nstruct Person { let name: String let birthday: Date } extension Person { init(name: String) { self.name = name self.birthday = Date() } } let person = Person(name: \u0026#34;NSStudent\u0026#34;, birthday: Date(timeIntervalSince1970: 426348250)) let baby = Person(name: \u0026#34;john\u0026#34;) ","date":"11 November 2020","externalUrl":null,"permalink":"/en/posts/1731339196747-struct-inits/","section":"Posts","summary":"","title":"Create a custom struct initializer","type":"posts"},{"content":"","date":"11 November 2020","externalUrl":null,"permalink":"/en/tags/struct/","section":"Tags","summary":"","title":"Struct","type":"tags"},{"content":"","date":"11 November 2020","externalUrl":null,"permalink":"/en/tags/tips/","section":"Tags","summary":"","title":"Tips","type":"tags"},{"content":"","date":"July 26, 2020","externalUrl":null,"permalink":"/tags/spm/","section":"Tags","summary":"","title":"Spm","type":"tags"},{"content":" Introducción # Normalmente, cuando desarrollamos, intentamos hacer nuestro código reutilizable. Muchas cosas que hacemos en nuestros proyectos son comunes, conectarte a una API, cachear las imágenes de la red, etc.\nPara poder manejar estos recursos normalmente hacemos uso de gestores de dependencias pero, para el desarrollo en iOS, no teníamos un gestor facilitado por Apple. Hasta hace bien poco la mayoría de los desarrolladores estábamos usando Cocoapods(poner link) o Carthage(poner link) para poder cubrir esta necesidad.\nCon Swift Package Manager (SPM) Apple intenta dar solución a esta demanda de los desarrolladores y en la última session de la WWDC han incluido cosas que hace a SPM un posible candidato para la gestión de dependencias en producción.\nMientras estás desarrollando tu dependencia una de las necesidades es poder modificar el código en tiempo de desarrollo dentro del proyecto. Apple no deja muy claro en su documentación como hacer esto, veamos paso por paso como poderlo hacer.\nEjemplo # El primer paso seria crear el package, para ello crea una carpeta en la ruta donde quieras hacer el ejemplo y dentro de esta carpeta ejecuta la inicialización del package.\nmkdir PackageExample cd PackageExample swift package init Para este tutorial vamos a crear el proyecto nuevo al que queremos incluir este package a la misma altura que la carpeta contenedora, esta seria la estructura de la carpeta actualmente.\nCarpeta Contenedora - ExampleProject - PackageExample El siguiente paso es arrastrar la carpeta del package en el proyecto\nUn detalle importante para que todo funcione es que no puedes tener abierto el package en el Xcode, de lo contrario no te mostrará la jerarquía de archivos al arrastrarlo.\nEl último paso que nos falta para que todo funcione es conectar la librería con el proyecto, esto se hace en la sección de Build Phases del proyecto en el apartado de Link Binary With Libraries, le damos al botón de + y seleccionamos la librería de nuestro package.\nCon esto ya podras hacer el import de tu package en el proyecto y modificar el código a tu gusto.\n","date":"July 26, 2020","externalUrl":null,"permalink":"/posts/1731267965610-trabajar-con-packages-en-local/","section":"Posts","summary":"","title":"Trabajar con Packages en local","type":"posts"},{"content":" About me # Hi, everyone!\nMy name is Omar, but I\u0026rsquo;m known as NSStudent. I\u0026rsquo;m an iOS developer from Madrid, Spain.\nWhen I have time, I like to go to NSCoder meetups to share knowledge with all developers from Madrid. One of the things that impressed me the most, when I started as an iOS developer, was the good atmosphere in the iOS community.\nThis is my personal website, blog and lab to test all new features of Swift.\nIf you want to talk to me more, you can contact with me via Twitter\nCheers!\n","externalUrl":null,"permalink":"/en/about/","section":"NSStudent blog","summary":"","title":"","type":"page"},{"content":"","externalUrl":null,"permalink":"/en/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/en/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/en/series/","section":"Series","summary":"","title":"Series","type":"series"}]